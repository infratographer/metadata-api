package graphapi

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.31

import (
	"context"
	"fmt"

	"go.infratographer.com/metadata-api/internal/ent/generated"
	"go.infratographer.com/metadata-api/internal/ent/generated/metadata"
	"go.infratographer.com/metadata-api/internal/ent/generated/status"
)

// StatusUpdate is the resolver for the statusUpdate field.
func (r *mutationResolver) StatusUpdate(ctx context.Context, input StatusUpdateInput) (*StatusUpdateResponse, error) {
	// TODO: authz check here
	status, err := r.client.Status.Query().Where(
		status.HasMetadataWith(metadata.NodeID(input.NodeID)),
		status.StatusNamespaceID(input.NamespaceID),
		status.Source(input.Source),
	).First(ctx)
	if err != nil {
		// TODO: check that error is the annotation doesn't exist

		md, err := r.client.Metadata.Query().Where(metadata.NodeID(input.NodeID)).First(ctx)
		if err != nil {
			// TODO: check that error is the metadata doesn't exist, otherwise return err
			md, err = r.client.Metadata.Create().SetNodeID(input.NodeID).Save(ctx)
			if err != nil {
				return nil, err
			}
		}

		status, err = r.client.Status.Create().SetInput(generated.CreateStatusInput{
			MetadataID:  md.ID,
			NamespaceID: input.NamespaceID,
			Source:      input.Source,
			Data:        input.Data,
		}).Save(ctx)
		if err != nil {
			fmt.Println("ERROR HERE 1")

			return nil, err
		}

		return &StatusUpdateResponse{Status: status}, nil
	}

	status, err = status.Update().SetData(input.Data).Save(ctx)
	if err != nil {
		return nil, err
	}

	return &StatusUpdateResponse{Status: status}, nil
}

// StatusDelete is the resolver for the statusDelete field.
func (r *mutationResolver) StatusDelete(ctx context.Context, input StatusDeleteInput) (*StatusDeleteResponse, error) {
	st, err := r.client.Status.Query().Where(
		status.HasMetadataWith(metadata.NodeID(input.NodeID)),
		status.StatusNamespaceID(input.NamespaceID),
		status.Source(input.Source),
	).First(ctx)
	if err != nil {
		return nil, err
	}

	err = r.client.Status.DeleteOne(st).Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &StatusDeleteResponse{DeletedID: st.ID}, nil
}
