package graphapi

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.37

import (
	"context"

	"go.infratographer.com/metadata-api/internal/ent/generated"
	"go.infratographer.com/metadata-api/internal/ent/generated/metadata"
	"go.infratographer.com/metadata-api/internal/ent/generated/status"
	"go.infratographer.com/permissions-api/pkg/permissions"
)

// StatusUpdate is the resolver for the statusUpdate field.
func (r *mutationResolver) StatusUpdate(ctx context.Context, input StatusUpdateInput) (*StatusUpdateResponse, error) {
	if err := permissions.CheckAccess(ctx, input.NamespaceID, actionMetadataStatusNamespaceUpdate); err != nil {
		return nil, err
	}

	_, err := r.client.StatusNamespace.Get(ctx, input.NamespaceID)
	if err != nil {
		return nil, err
	}

	status, err := r.client.Status.Query().Where(
		status.HasMetadataWith(metadata.NodeID(input.NodeID)),
		status.StatusNamespaceID(input.NamespaceID),
		status.Source(input.Source),
	).First(ctx)
	if err != nil {
		md, err := r.client.Metadata.Query().Where(metadata.NodeID(input.NodeID)).First(ctx)
		if err != nil {
			if generated.IsNotFound(err) {
				md, err = r.client.Metadata.Create().SetNodeID(input.NodeID).Save(ctx)
				if err != nil {
					return nil, err
				}
			} else {
				return nil, err
			}
		}

		status, err = r.client.Status.Create().SetInput(generated.CreateStatusInput{
			MetadataID:  md.ID,
			NamespaceID: input.NamespaceID,
			Source:      input.Source,
			Data:        input.Data,
		}).Save(ctx)
		if err != nil {
			return nil, err
		}

		return &StatusUpdateResponse{Status: status}, nil
	}

	status, err = status.Update().SetData(input.Data).Save(ctx)
	if err != nil {
		return nil, err
	}

	return &StatusUpdateResponse{Status: status}, nil
}

// StatusDelete is the resolver for the statusDelete field.
func (r *mutationResolver) StatusDelete(ctx context.Context, input StatusDeleteInput) (*StatusDeleteResponse, error) {
	if err := permissions.CheckAccess(ctx, input.NamespaceID, actionMetadataStatusNamespaceDelete); err != nil {
		return nil, err
	}

	st, err := r.client.Status.Query().Where(
		status.HasMetadataWith(metadata.NodeID(input.NodeID)),
		status.StatusNamespaceID(input.NamespaceID),
		status.Source(input.Source),
	).First(ctx)
	if err != nil {
		return nil, err
	}

	err = r.client.Status.DeleteOne(st).Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &StatusDeleteResponse{DeletedID: st.ID}, nil
}
