package graphapi

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.80

import (
	"context"
	"encoding/json"

	"github.com/nsf/jsondiff"
	"go.infratographer.com/metadata-api/internal/ent/generated"
	"go.infratographer.com/metadata-api/internal/ent/generated/annotation"
	"go.infratographer.com/metadata-api/internal/ent/generated/metadata"
	"go.infratographer.com/permissions-api/pkg/permissions"
	"go.infratographer.com/x/gidx"
)

// AnnotationUpdate is the resolver for the annotationUpdate field.
func (r *mutationResolver) AnnotationUpdate(ctx context.Context, input AnnotationUpdateInput) (*AnnotationUpdateResponse, error) {
	logger := r.logger.With("nodeID", input.NodeID, "namespaceID", input.NamespaceID)

	if input.NamespaceID == "" {
		return nil, NewInvalidFieldError("namespaceID", ErrFieldEmpty)
	}

	if _, err := gidx.Parse(input.NamespaceID.String()); err != nil {
		return nil, NewInvalidFieldError("namespaceID", err)
	}

	if input.NodeID == "" {
		return nil, NewInvalidFieldError("nodeID", ErrFieldEmpty)
	}

	if _, err := gidx.Parse(input.NodeID.String()); err != nil {
		return nil, NewInvalidFieldError("nodeID", err)
	}

	if !json.Valid(input.Data) {
		return nil, NewInvalidFieldError("data", ErrInvalidJSON)
	}

	_, err := r.client.AnnotationNamespace.Get(ctx, input.NamespaceID)
	if err != nil {
		if generated.IsNotFound(err) {
			return nil, err
		}

		logger.Errorw("failed to get annotation namespace", "error", err)
		return nil, ErrInternalServerError
	}

	if err := permissions.CheckAccess(ctx, input.NamespaceID, actionMetadataAnnotationNamespaceUpdate); err != nil {
		return nil, err
	}

	ant, err := r.client.Annotation.Query().Where(
		annotation.AnnotationNamespaceID(input.NamespaceID),
		annotation.HasMetadataWith(metadata.NodeID(input.NodeID)),
	).First(ctx)
	if err != nil {
		// The annotation doesn't exist, create it
		if generated.IsNotFound(err) {
			md, err := r.client.Metadata.Query().Where(metadata.NodeID(input.NodeID)).First(ctx)
			if err != nil {
				// metadata doesn't exist, create it
				if generated.IsNotFound(err) {
					md, err = r.client.Metadata.Create().SetNodeID(input.NodeID).Save(ctx)
					if err != nil {
						logger.Errorw("failed to create metadata", "error", err)
						return nil, ErrInternalServerError
					}
				} else {
					logger.Errorw("failed to get metadata", "error", err)
					return nil, ErrInternalServerError
				}
			}

			ant, err = r.client.Annotation.Create().SetMetadata(md).SetAnnotationNamespaceID(input.NamespaceID).SetData(input.Data).Save(ctx)
			if err != nil {
				logger.Errorw("failed to create annotation", "error", err)
				return nil, ErrInternalServerError
			}

			return &AnnotationUpdateResponse{Annotation: ant}, nil
		} else {
			logger.Errorw("failed to get annotation", "error", err)
			return nil, ErrInternalServerError
		}
	}
	update := ant.Update()

	opts := jsondiff.DefaultJSONOptions()
	diffResult, _ := jsondiff.Compare(ant.Data, input.Data, &opts)
	if diffResult != jsondiff.FullMatch {
		update.SetData(input.Data)
	}

	// trigger update even when data doesn't change to update the updated_at timestamp
	ant, err = update.Save(ctx)
	if err != nil {
		logger.Errorw("failed to update annotation", "error", err)
		return nil, ErrInternalServerError
	}

	return &AnnotationUpdateResponse{Annotation: ant}, nil
}

// AnnotationDelete is the resolver for the annotationDelete field.
func (r *mutationResolver) AnnotationDelete(ctx context.Context, input AnnotationDeleteInput) (*AnnotationDeleteResponse, error) {
	logger := r.logger.With("nodeID", input.NodeID, "namespaceID", input.NamespaceID)

	if input.NamespaceID == "" {
		return nil, NewInvalidFieldError("namespaceID", ErrFieldEmpty)
	}

	if _, err := gidx.Parse(input.NamespaceID.String()); err != nil {
		return nil, NewInvalidFieldError("namespaceID", err)
	}

	if input.NodeID == "" {
		return nil, NewInvalidFieldError("nodeID", ErrFieldEmpty)
	}

	if _, err := gidx.Parse(input.NodeID.String()); err != nil {
		return nil, NewInvalidFieldError("nodeID", err)
	}

	ant, err := r.client.Annotation.Query().Where(
		annotation.AnnotationNamespaceID(input.NamespaceID),
		annotation.HasMetadataWith(metadata.NodeID(input.NodeID)),
	).First(ctx)
	if err != nil {
		if generated.IsNotFound(err) {
			return nil, err
		}

		logger.Errorw("failed to get annotation", "error", err)
		return nil, ErrInternalServerError
	}

	if err := permissions.CheckAccess(ctx, input.NamespaceID, actionMetadataAnnotationNamespaceUpdate); err != nil {
		return nil, err
	}

	if err = r.client.Annotation.DeleteOne(ant).Exec(ctx); err != nil {
		logger.Errorw("failed to delete annotation", "error", err)
		return nil, ErrInternalServerError
	}

	return &AnnotationDeleteResponse{DeletedID: ant.ID}, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

type mutationResolver struct{ *Resolver }
